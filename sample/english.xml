<paper status="dev" xmlns:dk="http://www.kirsanov.com">
  <title>Implementing an Internal DSL</title>
  <version date="2007-09-03">First Draft</version>
<version date="2008-04-08 09:20 EDT">Added early section on
command-query vs fluent interfaces</version>
  <abstract></abstract>
<contents/>
<body>
<indexterm zone="" significance="preferred"><primary>internal DSLs</primary></indexterm>

  <p>Now that I've gone through some general issues in implementing DSLs,
  it's time to go into the specifics of implementing particular
  flavors of DSLs. I've <dk:nobr>decided to</dk:nobr> start with internal DSLs as they
  are often the most approachable form of DSLs to write. Unlike
  external DSLs, you don't need to learn about grammars and language
  parsing, and unlike language workbenches, you don't need any special
  tools. With internal DSLs you work in your regular language
  environment. As a result, it's no surprise that there's been a lot of
  interest in internal DSLs in the last couple of years.</p>
  <p>When you use internal DSLs, you are very much constrained by your host
  language. Since any expression you use must be a legal expression in
  your <dk:nobr>host language,</dk:nobr> a lot of thought in internal DSL usage is bound
  up in language features. A good bit of the recent impetus behind
  internal DSLs comes from the Ruby community, whose language has many
  features which encourage DSLs. However, many Ruby techniques can be
  used in other languages too, if usually not as elegantly. And the
  doyen on internal DSL thinking is Lisp, one of the world's oldest
  computer languages with a limited but very appropriate set of
  features for the job.
<indexterm><primary>Ruby</primary></indexterm>
<indexterm><primary>Lisp</primary></indexterm>
  </p>
</body>
</paper>
